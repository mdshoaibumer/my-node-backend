const PdfPrinter = require('pdfmake');
const fs = require('fs');
const path = require('path');
const { format } = require('date-fns');
const { generateSeverityChart } = require('./chartGeneration');

function parseSuggestion(suggestion) {
  const suggestionText = typeof suggestion === 'string' 
    ? suggestion 
    : suggestion?.suggestion || '';

  if (!suggestionText) return null;

  // Add screen reader specific parsing
  if (suggestionText.match('screenreader')) {
    return {
      explanation: suggestion,
      fixedHTML: '',
      steps: [],
      wcag: 'WCAG 2.1 Success Criterion 4.1.2 (Name, Role, Value)'
    };
  }

  const sections = {
    explanation: '',
    fixedHTML: '',
    steps: [],
    wcag: ''
  };

  const explanationMatch = suggestionText.match(/### Concise Technical Explanation([\s\S]*?)(?=###)/i);
  const fixedHTMLMatch = suggestionText.match(/### Fixed HTML Snippet([\s\S]*?)(?=###)/i);
  const stepsMatch = suggestionText.match(/### Implementation Steps([\s\S]*?)(?=###)/i);
  const wcagMatch = suggestionText.match(/### WCAG Reference([\s\S]*)/i);

  if (explanationMatch) sections.explanation = explanationMatch[1].trim();
  if (fixedHTMLMatch) sections.fixedHTML = fixedHTMLMatch[1].trim();
  if (stepsMatch) {
    sections.steps = stepsMatch[1].trim().split('\n')
      .filter(step => step.trim().length > 0);
  }
  if (wcagMatch) sections.wcag = wcagMatch[1].trim();

  return sections;
}

function formatSuggestion(suggestion) {
  const suggestionText = typeof suggestion === 'string' 
    ? suggestion 
    : suggestion?.suggestion || '';
  const parsed = parseSuggestion(suggestionText);
  if (!parsed) return 'No suggestion available';
  
  let formatted = '';
  if (parsed.explanation) {
    formatted += `Explanation:\n${parsed.explanation}\n\n`;
  }
  if (parsed.fixedHTML) {
    formatted += `Fixed HTML:\n${parsed.fixedHTML}\n\n`;
  }
  if (parsed.steps.length > 0) {
    formatted += `Implementation Steps:\n`;
    parsed.steps.forEach((step, i) => {
      formatted += `${i + 1}. ${step}\n`;
    });
    formatted += '\n';
  }
  if (parsed.wcag) {
    formatted += `WCAG Reference:\n${parsed.wcag}`;
  }
  
  return formatted || suggestionText || 'No suggestion available';
}

const fonts = {
  Roboto: {
    normal: path.join(__dirname, '../../fonts/Roboto-Regular.ttf'),
    bold: path.join(__dirname, '../../fonts/Roboto-Bold.ttf'),
    italics: path.join(__dirname, '../../fonts/Roboto-Italic.ttf'),
    bolditalics: path.join(__dirname, '../../fonts/Roboto-BoldItalic.ttf')
  }
};

const printer = new PdfPrinter({
  Roboto: fonts.Roboto
});

async function generatePDFReport(results, outputPath) {
  const { url, scannedAt, scanDuration, metrics, violations } = results;

  // Generate chart image
  let chartImage = null;
  try {
    chartImage = await generateSeverityChart(metrics);
  } catch (error) {
    console.error('Chart generation failed:', error);
  }

  // Document Definition
  const docDefinition = {
    pageSize: 'A4',
    pageMargins: [40, 60, 40, 60],
    header: {
      text: 'Generated by ComplyAI Accessibility Scanner',
      alignment: 'right',
      margin: [0, 20, 20, 0],
      fontSize: 8,
      color: '#666'
    },
    footer: function(currentPage, pageCount) {
      return {
        text: `Page ${currentPage} of ${pageCount}`,
        alignment: 'center',
        fontSize: 8,
        margin: [0, 0, 0, 20]
      };
    },
    content: [
      // Header Section
      {
        columns: [
          { 
            text: '508 Compliance Report', 
            style: 'header',
            width: '70%'
          },
          {
            text: `Risk Score: ${metrics.riskScore}`,
            style: metrics.riskScore > 70 ? 'riskScoreHigh' : 
                  metrics.riskScore > 40 ? 'riskScoreMedium' : 'riskScoreLow',
            alignment: 'right'
          }
        ],
        margin: [0, 0, 0, 20]
      },
      
      // Summary Table
      {
        table: {
          widths: ['auto', '*'],
          body: [
            [{ text: 'Scan Summary', style: 'tableHeader', colSpan: 2 }, {}],
            ['Scanned URL', { text: url, style: 'urlText' }],
            ['Scan Date', results.scannedAt ? format(new Date(results.scannedAt), 'yyyy-MM-dd HH:mm:ss') : 'Not available'],
            ['Scan Duration', results.scanDuration || 'Not measured'],
            ['Total Violations', metrics.violationCount || 0],
            ['Critical Issues', metrics.severityBreakdown?.critical || 0]
          ]
        },
        layout: 'noBorders',
        margin: [0, 0, 0, 30]
      },
      
      // Severity Chart
      chartImage ? {
        text: 'Violation Severity Distribution',
        style: 'sectionHeader',
        margin: [0, 0, 0, 10]
      } : null,
      chartImage ? {
        image: chartImage,
        width: 500,
        alignment: 'center',
        margin: [0, 10, 0, 30]
      } : null,
      
      // Keyboard Navigation Issues
      {
        text: 'Keyboard Navigation Issues',
        style: 'sectionHeader'
      },
      ...(results.keyboardIssues || []).map(issue => ({
        text: `${issue.type}: ${issue.message}`,
        style: 'violationDescription',
        margin: [0, 5, 0, 10]
      })),
      
      // Screen Reader Compatibility
      {
        text: 'Screen Reader Compatibility',
        style: 'sectionHeader'
      },
      ...(results.screenReaderIssues || []).map(issue => ({
        text: `${issue.type}: ${issue.message}`,
        style: 'violationDescription',
        margin: [0, 5, 0, 10]
      })),
      
      // Screen Reader Compatibility Issues with Suggestions
      ...(results.screenReaderIssues && results.screenReaderIssues.length > 0 ? [
        {
          text: 'Screen Reader Compatibility Issues',
          style: 'sectionHeader',
          pageBreak: 'before'
        },
        ...results.screenReaderIssues.map(issue => ({
          stack: [
            { 
              text: `${issue.type} (${issue.severity || 'medium'})`, 
              style: 'violationTitle',
              margin: [0, 0, 0, 5]
            },
            { 
              text: issue.message,
              style: 'violationDescription'
            },
            {
              text: 'Affected Element:',
              style: 'violationSubtitle',
              margin: [0, 10, 0, 5]
            },
            {
              text: issue.element,
              style: 'codeBlock',
              margin: [0, 0, 0, 10]
            },
            issue.suggestion && {
              text: 'Recommended Fix:',
              style: 'violationSubtitle',
              margin: [0, 10, 0, 5]
            },
            issue.suggestion && {
              text: formatSuggestion(issue.suggestion),
              style: 'fixContent',
              margin: [0, 0, 0, 20]
            },
            { 
              canvas: [{ type: 'line', x1: 0, y1: 5, x2: 515, y2: 5, lineWidth: 0.5 }],
              margin: [0, 10, 0, 20]
            }
          ].filter(Boolean)
        }))
      ] : []),
      
      // Violations Details
      {
        text: 'Detailed Findings',
        style: 'sectionHeader',
        pageBreak: 'before'
      },
      ...violations.map(violation => ({
        stack: [
          { 
            text: `${violation.id} (${violation.severity.toUpperCase()})`, 
            style: 'violationTitle',
            margin: [0, 0, 0, 5]
          },
          { 
            text: violation.description,
            style: 'violationDescription'
          },
          {
            text: 'Affected Element:',
            style: 'violationSubtitle',
            margin: [0, 10, 0, 5]
          },
          {
            text: violation.nodes[0].html,
            style: 'codeBlock',
            margin: [0, 0, 0, 10]
          },
          {
            text: 'Recommended Fix:',
            style: 'violationSubtitle',
            margin: [0, 10, 0, 5]
          },
          {
            text: formatSuggestion(violation.suggestion?.suggestion || ''),
            style: 'fixContent',
            margin: [0, 0, 0, 20]
          },
          { 
            canvas: [{ type: 'line', x1: 0, y1: 5, x2: 515, y2: 5, lineWidth: 0.5 }],
            margin: [0, 10, 0, 20]
          }
        ],
        pageBreak: 'after'
      })),
      
      // ATAG 2.0 Compliance
      {
        text: 'ATAG 2.0 Compliance',
        style: 'sectionHeader',
        pageBreak: 'before'
      },
      ...(results.authoringViolations || []).map(violation => ({
        stack: [
          { 
            text: `${violation.id}: ${violation.description}`, 
            style: 'violationDescription',
            margin: [0, 5, 0, 10]
          },
          {
            text: 'Affected Element:',
            style: 'violationSubtitle',
            margin: [0, 10, 0, 5]
          },
          {
            text: violation.nodes[0].html,
            style: 'codeBlock',
            margin: [0, 0, 0, 10]
          },
          {
            text: 'Recommended Fix:',
            style: 'violationSubtitle',
            margin: [0, 10, 0, 5]
          },
          {
            text: formatSuggestion(violation.suggestion?.suggestion || ''),
            style: 'fixContent',
            margin: [0, 0, 0, 20]
          }
        ],
        margin: [0, 0, 0, 20]
      }))
    ].filter(Boolean), // Remove null entries
    
    styles: {
      header: {
        fontSize: 24,
        bold: true,
        color: '#2c3e50'
      },
      riskScoreHigh: {
        fontSize: 18,
        bold: true,
        color: '#e74c3c'
      },
      riskScoreMedium: {
        fontSize: 18,
        bold: true,
        color: '#f39c12'
      },
      riskScoreLow: {
        fontSize: 18,
        bold: true,
        color: '#2ecc71'
      },
      tableHeader: {
        bold: true,
        fontSize: 14,
        color: '#3498db',
        margin: [0, 0, 0, 10]
      },
      urlText: {
        color: '#3498db',
        decoration: 'underline'
      },
      violationTitle: {
        fontSize: 16,
        bold: true,
        color: '#e74c3c'
      },
      violationDescription: {
        fontSize: 12,
        margin: [0, 0, 0, 10]
      },
      violationSubtitle: {
        fontSize: 12,
        bold: true,
        color: '#2c3e50'
      },
      codeBlock: {
        fontSize: 10,
        background: '#f8f9fa',
        border: [1, '#ddd'],
        padding: 5
      },
      fixContent: {
        fontSize: 12,
        lineHeight: 1.4
      },
      sectionHeader: {
        fontSize: 18,
        bold: true,
        margin: [0, 0, 0, 10],
        color: '#3498db'
      }
    },
    defaultStyle: {
      font: 'Roboto',
      fontSize: 12,
      lineHeight: 1.4
    }
  };

  // Generate PDF
  return new Promise((resolve, reject) => {
    console.log('Creating PDF document...');
    const pdfDoc = printer.createPdfKitDocument(docDefinition);
    console.log('PDF document created, setting up streams...');
    const stream = fs.createWriteStream(outputPath);
    
    pdfDoc.pipe(stream);
    pdfDoc.on('end', () => resolve(outputPath));
    pdfDoc.on('error', reject);
    pdfDoc.end();
  });
}

module.exports = { generatePDFReport };